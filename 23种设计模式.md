# 23种设计模式

## 设计模式的重要性

1. 软件中的设计模式是对软件设计中普遍存在的各种问题，提出的解决方案。
2. 在实际开发过程中客户添加新功能。
3. 原来的程序员离职（维护性，可读性，规范性）
4. 目前程序员门槛越来越高
5. 设计模式在什么地方用过？面向对象-》功能模块【设计模式+算法】-》框架-》集群【服务器集群】
6. 如果想要成为合格的软件工程师，研究设计模式是非常必要的

## 设计模式的目的

编写代码过程中，程序员面临着来自耦合性，内聚性以及可维护性，重用性，灵活性等方面的挑战，设计模式是为了让程序（软件），具有更好

1. 代码的重用性（相同功能代码，不能多次编写）
2. 可读性（编写的代码规范，便于程序员阅读理解）
3. 可扩展性（当添加新功能时非常方便 ）
4. 可靠性（当添加新功能时，不会影响原来的功能）
5. 使程序呈现高内聚，低耦合的特性

- #### 金句

设计模式包含了面向对象的精髓，懂了设计模式，你就懂了面向对象和设计的精髓。

## 设计模式的七大原则

1. 单一职责原则
2. 接口隔离原则
3. 依赖倒置（倒转）原则
4. 里氏原则
5. 开闭原则
6. 迪米特发展
7. 合成复用原则

### 单一职责原则

对类来说的，即一个类只负责一项职责。如果A负责两个不同职责：职责1，职责2。当职责1发生改变时，可能造成职责2的改变。所有需要将A分解为A1，A2两个类

```java
package com.atguigu.singlere.sponsibility;

public class SingleRespensibility1 {
    public static void main(String[] args) {
        Vehicle v=new Vehicle();
        v.runWater("轮船");
        v.run("汽车");
        v.runAri("飞机");


    }
}
//在run方法中违反了单一原则
//解决方法在不同的方法中创建不同的类
//class Vehicle{
//    public void run (String verhiche){
//        System.out.println(verhiche+"在路上");
//    }
//}
//解决方法三
//方法级别的单一职责
class Vehicle{
    public void run (String verhiche){
        System.out.println(verhiche+"在路上");
    }  public void runAri (String verhiche){
        System.out.println(verhiche+"在路上");
    }public void runWater (String verhiche){
        System.out.println(verhiche+"在路上");
    }
}
```

#### 单一职责原则注意的事项细节

1. 降低类的复杂度，一个类只负责一项职责
2. 提高类的可读性，可维护性
3. 降低变革风险
4. 通常情况下我们应该遵守单一职责原则，只有逻辑足够简单的时候，才可以在代码中违反单一原则：方法足够少，可以在方法级别单一职责原则

### 接口隔离原则

1. 客户端不应该依赖它不需要的接口，一个类对另一个接口应该应该建立在最小接口上

2. ![image-20200828071113488](C:\Users\xiao\AppData\Roaming\Typora\typora-user-images\image-20200828071113488.png)

3. 类A通过接口interface1依赖于类B，类C通过接口interface1依赖于D，如果接口interface1对于类A和类C来说不是最小接口，那么类B和D去实现他们不需要的方法

4. 按接口隔离原则应当这样处理

   将接口Interface1拆分为几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

#### 实例如下

类A通过接口interface1依赖于类B，类C通过接口interface1依赖于类D编码如下

没有使用接口原则的时候

#### 传统方法的接口问题和使用接口隔离原则进行改进

1. 类A通过接口interface1依赖于B，类C通过接口interface依赖D类，如果接口interface对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法

2. 将接口interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则。

3. 接口interface1中出现的方法，根据实际情况进行拆分为三个接口

   ![image-20200828074839584](C:\Users\xiao\AppData\Roaming\Typora\typora-user-images\image-20200828074839584.png)

4. 编码如下

   ```java
   package com.atguigu.principle.segregation;
   
   public class Segregation1 {
       public static void main(String[] args) {
           A a = new A();
           a.depend1(new B());
           a.depend2(new B());
           a.depend3(new B());
           C c = new C();
           c.depend1(new D());
           c.depend4(new D());
           c.depend5(new D());
       }
   }
   
   interface Interface1 {
       void operation1();
   }
   
   interface Interface2 {
       void operation2();
   
       void operation3();
   }
   
   interface Interface3 {
       void operation4();
   
       void operation5();
   }
   
   class B implements Interface1,Interface2 {
   
       @Override
       public void operation1() {
           System.out.println("B实现了operation1");
       }
   
       @Override
       public void operation2() {
           System.out.println("B实现了operation2");
   
       }
   
       @Override
       public void operation3() {
           System.out.println("B实现了operation2");
   
       }
   }
   
   class D implements Interface1,Interface3 {
   
       @Override
       public void operation1() {
           System.out.println("D实现了operation1");
       }
       @Override
       public void operation4() {
           System.out.println("D实现了operation3");
   
       }
   
       @Override
       public void operation5() {
           System.out.println("D实现了operation3");
   
       }
   }
   class A {
       public void depend1(Interface1 i) {
           i.operation1();
       }
   
       public void depend3(Interface2 i) {
           i.operation3();
       }
   
       public void depend2(Interface2 i) {
           i.operation2();
       }
   }
   
   class C {
       public void depend1(Interface1 i) {
           i.operation1();
       }
   
       public void depend4(Interface3 i) {
           i.operation4();
       }
   
       public void depend5(Interface3 i) {
           i.operation5();
       }
   }
   
   ```

   